##' \code{loadings(object)} and then design your own plotting method.
##' @title Side by side scores and loadings plot
##' @usage slplot(object, pcs=c(1,2), scoresLoadings=c(TRUE, TRUE),
##' sl="def", ll="def", hotelling=0.95, rug=TRUE, sub=NULL,...)
##' @param object 
##' @param pcs 
##' @return None, used for side effect.
##' @author Henning Redestig
setMethod("slplot", "pcaRes",
          function(object, pcs=c(1,2)) {
#(ess-roxy-get-function-args)
  opar <- par(no.readonly=TRUE)
  cl <- match.call()
})

##' .. content for \description{} (no empty lines) ..
##'
##' .. content for \details{} ..
##' @title 
##' @param a 
##' @param b 
##' @param d 
##' @param asd 
##' @return 
##' @author Henning Redestig
trickyInArgsComments <- function(a,#comment
                                 b,#hejhopp trams
                                 d,asd) {
  print("hello")
}

setClass(Class="inference", representation=representation(model="character"
                                   , sample.size="numeric"
                                   , robust.se="logical"
                                   , two.sided="logical"
                                   , ci.level="numeric"), contains=c("matrix"))

##' .. content for \description{} (no empty lines) 
##' 
##' .. content for \details{} ..
##' @title asd
##' @param a 
##' @param asdsd 
##' @param sd 
##' @param ... 
##' @return s
##' @author Henning Redestig
tempFixNasFunction <- function(a,asdsd, sd, ...) {
  asds 
}

setGeneric("updateMu", function(respM, gamma, ...)
          standardGeneric("updateMu"))


## (make-local-variable 'adaptive-fill-regexp)
## (setq adaptive-fill-regexp (concat ess-roxy-str adaptive-fill-regexp))
## (make-local-variable 'adaptive-fill-first-line-regexp)
## (setq adaptive-fill-first-line-regexp (concat ess-roxy-str adaptive-fill-first-line-regexp))
## (make-local-variable 'paragraph-start)
## (setq paragraph-start (concat "\\(" ess-roxy-str "\\)*" paragraph-start))
## (make-local-variable 'paragraph-separate)
## (setq paragraph-separate (concat "\\(" ess-roxy-str "\\)*" paragraph-separate))
## (auto-fill-mode)
asd

##'   aqdasd lksa odnsl dlsakdn lsakdn sladn  asijdi j 1. asdsd alksnd
##'   lasdn ldnad
##' 
##'
##' alkdnal dl lakd lasdnladna ld aldan lda dlakd nladn a amd lakdn
##' ajdn asjdns
##'
##'    lajnsd jasdn aksjdnaksjnd asjdnaksdnajsdnajsd aksdn askdjn
##'    akjdn aksdnkasjdnka
##' 
##'       1. aldn adlnsald ladn saldnlaksd naskl
##'       2. ad asdjnksadn adjn skajan kda dksadkas dkjan dkasndkadn
##'       ajsd nkj dakjd sd
##' @title hej
##' @param fitta asdadsd
##' 1.
##' 	2. asd
##' @param diagonals pung asa as a  sad s dsa da das d asd asd
##' add
##' @param tjo asd
##' @param asdasd 
##' @return me
##' @author Henning Redestig
tempFixNas <- function(fitta, diagonals, tjo, asdasd) {

  for(i in index) {
    data <- otherdata[i]
  }

}


##' Simply replace completely ajksbdkjsa djskbdkajbd
##' 
##' ksdb skdb skasdaj ahd (ess-roxy-beg-of-field) (newline-and-indent)
##' aksndlsakndlksdn jkahd ksn dkjands 
##' @title Temporary fix for missing values
##' @param diagonals The diagonal to be replaced, i.e. the first,
##' second and so on when looking at the fat version of the matrix
##' @param tjo asdsdsdw
##' @return The original matrix with completely missing rows/cols
##' filled with zeroes. oasndsnd aksdnkasdnskans dkas ndkjasndksdn
##' skandkand ksjandknsd
##' @export
##' @examples  
##' tempFixNas(iris)
##' pi <- 1
##' plot(x)
##' @author Henning Redestig 
tempFixNas <- function(diagonals, tjo) {
  (ess-roxy-delete-args)
wilcox.test
(ess-roxy-goto-end-of-entry)
  badRows <- apply(mat, 1, function(x) all(is.na(x)))
  badCols <- apply(mat, 2, function(x) all(is.na(x)))
  mat[ badRows,] <- 0 (ess-roxy-get-args-list-from-def)
  mat[,badCols ] <- 0 (ess-roxy-get-args-list-from-entry)
  mat 
}

##' <description>
##'
##' <details> 
##' @title asdsd
##' @param asd asd
##' @param test1 asd
##' @param asdsd 
##' @param tjo asdasd
##' @return aa
##' @author Henning Redestig
tempFixNas <- function(asd,test1,asdsd,tjo=c("asd", "asdasd")) {
## (ess-roxy-goto-end-of-entry)  
##   (setq fun (ess-roxy-get-args-list-from-def))
##   (setq ent (ess-roxy-get-args-list-from-entry))
##   (ess-roxy-merge-args fun ent) 
##   (ess-roxy-mrg-args fun ent) 
##   (ess-roxy-get-args-list-from-entry)
## (ess-roxy-get-function-args)
## (ess-roxy-goto-end-of-entry)

##   (setq here (ess-roxy-delete-args)) 
##   (ess-roxy-insert-args (ess-roxy-get-args-list-from-def) here)
  badRows <- apply(mat, 1, function(x) all(is.na(x)))
  badCols <- apply(mat, 2, function(x) all(is.na(x)))
  mat[ badRows,] <- 0
  mat[,badCols ] <- 0 
  mat 
}

##' <description>
##'
##' <details>
##' @title my title
##' @param test1 
##' @param tjo 
##' @param pung 
##' @param str 
##' @return value
##' @author Henning Redestig
tempFixNasBad <- function(test1,tjo=c("asd", "asdasd"), pung, str) {
asdsd# (car (cdr (ess-end-of-function nil t))) 
}

##' Provides Bayesian PCA, Probabilistic PCA, Nipals PCA, Inverse
##' Non-Linear PCA and the conventional SVD PCA. A cluster  based
##' method for missing value estimation is included for comparison.
##' BPCA, PPCA and NipalsPCA may be used to perform PCA on incomplete
##' data as well as for accurate missing value estimation.  A set of
##' methods for printing and plotting the results is also provided.
##' All PCA methods make use of the same data structure (pcaRes) to
##' provide a unique interface to the PCA results. Developed at the
##' Max-Planck Institute for Molecular Plant Physiology, Golm,
##' Germany, RIKEN Plant Science Center Yokohama, Japan, and CAS-MPG
##' Partner Institute for Computational Biology (PICB) Shanghai,
##' P.R. China
##'
##' @name pcaMethods
##' @aliases pcaMethods
##' @docType package
##' @title pcaMethods
##' @useDynLib pcaMethods
##' @author Wolfram Stacklies, Henning Redestig
NULL


asdsd
